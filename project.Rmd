---
title: "Memory analysis"
output:
  html_document:
    df_print: paged
    css: style.css
  html_notebook:
    css: style.css
---
## Introduction
Currently, many apps with micro games claim to help people improve their brain skills like memory, mathematics, and problem-solving through daily use. 
In this little experiment, we focus on a memory game to discover patterns in the Games and test if there is a real improvement in people who plays many times.

### Targets
- Evaluate if there is an improvement in people who have played more games
- Observe if there are models for the matches
- Discover if there is a pattern between wrong pairs

### Methodology
Memory game was thought to be used on smartphones. Then each game has only 24 
cards (12 pairs) arranged in a grid of six rows and four columns. At the
beginning of the game, the player has 5 seconds to see all the cards and memorize
their locations. Later every time a pair is open user has 1 second to see and 
continue.

Once the game is over, a record is created with all the moves made for the player. 
Each movement is made of 8 variables, image, coordinates ( x, y ), and the 
timestamp to mark the moment when the cards were open. This data is useful for 
analyzing the game. The coordinates, for example, will allow you to observe if 
there are points on the screen where the players concentrate more attention.

### Libraries
```{r message=FALSE, warning=FALSE}
library(tidyr)
library(ggplot2)
library(dplyr)
library(mongolite)
library(modelr)
library(cowplot)
library(ggraph)
library(igraph)
library(lubridate)
```

```{r include=FALSE}
# Styles
mytheme<-theme_void()+
        theme(
          panel.background = element_rect(fill = "#0c1329",colour = NA_character_),# necessary to avoid drawing panel outline
         plot.background = element_rect(fill = "#0c1329",,colour = NA_character_),
         legend.text = element_text(colour = "white"),
         legend.title = element_text(face = "bold", colour = "white"),
         plot.title = element_text(face = "bold", colour = "white"),
         legend.box.background = element_rect(fill = "#0c1329", color= "#0c1329"),
          axis.text=element_text(colour = "white"),
         axis.title=element_text(colour = "white")) 
themeBars<- theme( axis.text=element_text(colour = "white"),
         panel.grid.major = element_line(colour = "white"),
         panel.grid.minor = element_line(colour = "white"))
colors=c( "#5F00AD",
    "#7700B8",
    "#7E00C2",
    "#7D00B8",
    "#8700B8",
    "#9900B8",
    "#9A00A8",
    "#A30096",
    "#A8007B",
    "#B30071",
    "#B30056",
    "#A80051",
    "#C20067",
    "#CC0074",
    "#FF05A8",
    "#FF2E8C",
    "#FF584D",
    "#FF7857",
    "#FFAE57",
    "#FFC466",
    "#FFDE85",
    "#FFF4B8",
    "#FAFFC2")
colorSex=c("#FF7857","#5F00AD")
pink= "#FF2E8C"
```

### Exporting Data
```{r include=FALSE}
urldb='mongodb+srv://admin:AvrilFG123@mystore.96rrl.mongodb.net/game-memory?retryWrites=true&w=majority'
```
```{r}

connectionGames = mongo(collection="games", url=urldb)
connectionUsers = mongo(collection="users", url=urldb)
connectionMoves = mongo(collection="moves", url=urldb)

games <- connectionGames$find('{}',fields = '{"user":true}')%>%as_tibble()
user <- connectionUsers$find('{}',fields = '{"age" : true,"sex":true,"email":true }')%>%as_tibble()
moves <- connectionMoves$find('{}')%>%as_tibble()
```
### Transform Data
First of all, separating the columns card1, and card2 into three variables is 
necessary because the image and coordinates (x, y) were saved in the database as
a vector. Then create one table joining tables games users and moves.
```{r}
separateList <- function(df,column, names){
  return(
    df%>%
      unnest(column )%>% # separate a list a create new to rows
      group_by(id) %>% 
      mutate(col = names ) %>% #add a column indicator
      spread(key = col, value = column)
  )
}
```
```{r message=FALSE, warning=FALSE, result=FALSE}

 full_table <- moves %>% 
  mutate(id = 1:nrow(moves)) %>% 
  separateList('card1', c('x1', 'y1', 'emoji1')) %>%   
  separateList('card2', c('x2', 'y2', 'emoji2')) %>%
  inner_join(games, by=c("game" = "_id" ))%>%
  inner_join(user, by=c("user" = "_id" ))

full_table$id = NULL

```
Build a table that summarizes each game, notice this table has information about 
how many moves were required to win, the duration of the game base on the timestamp 
of moves, and some information about the first and last emojis opened
```{r echo=TRUE, message=FALSE, warning=FALSE}
user_summarise <- full_table %>%
    arrange(start) %>% 
    group_by(game, user, sex ) %>% 
    mutate(time = end-start) %>%
    summarise(count = n(),
              mean = mean(time), 
              score = mean(match), 
              start_game = first(start), 
              end_game = last(end), 
              firstEmoji = first(emoji1),
              secondEmoji = nth(emoji1,2),
              thirdEmoji = nth(emoji1,3),
              last2Emoji = nth(emoji1,-3),
              last1Emoji = nth(emoji1,-2),
              lastEmoji = last(emoji1)
              , .groups = 'drop') %>% # each row is a game
    arrange(start_game)%>% # order by start game
    group_by(user)%>%
    mutate(game = row_number(), # change game id to an increasing number
           duration = end_game-start_game)
user_summarise
```

### Analysis
To have a preview of the data generate a scatter plot with the score, game, and user.
```{r echo=FALSE}
ggplot(data=user_summarise, mapping = aes(x = start_game, y=score, color=user))+
  geom_point(size=3)+
  mytheme+
  themeBars
```
The graph gives us some interesting information. There is a group that 
uses the app more. In effect, if we realize another graph number of games by 
the user, the differences becomes clear.
```{r}
ggplot(data=user_summarise)+
  geom_bar(mapping = aes(x = reorder(user,-game), fill = sex))+
  theme_void()+
  scale_fill_manual(values=colorSex)+
  mytheme+
  themeBars+
  theme(axis.text.x=element_blank())+
  ggtitle('Games by user')+
  ylab('# games')+
  xlab('user')
```
Here we can observe it is a bit improvement after the 8th game this could 
happen because as a person who trains every day the results don't get
visible immediately
```{r}
user_summarise %>%
  filter(game<=11) %>%
  ggplot(aes(game,score, group=game))+
  geom_boxplot( fill = pink, colour = "white")+
  ggtitle("Score by game")+
  mytheme+
  themeBars
```
Now if we get the data generates by the user with more game we can
detect some things.

- The mean is almost always over 0.6 and seams to be limit on 0.8.
- The behavior of the score is similar to a Sine wave.
This could suggest there is a cycle on the performance even training every day

```{r}
user_summarise %>%
  filter(game>11) %>%
  ggplot(aes(game,score, group=game))+
  geom_boxplot( fill = pink, colour = "white")+
  labs(title="Score by game")+
  mytheme+
  themeBars
```
Meanwhile, taking the score and game duration present a clear correlation. The 
result is completely normal, more wrong pairs longer the game as well. 
Another reason could be if the user waits before start loses memory. 

Finally, the reason why is a curve and not a line is simple, each wrong pair 
force to open two another two pairs.

```{r}
more_games_2 = user_summarise%>%mutate(duration= as.numeric(duration))

mod <- lm(score ~ log(duration), data = more_games_2)
more_games_2%>%
  add_predictions(mod)%>%
  ggplot(aes(duration,score))+
  geom_point(color=pink)+
  geom_line(aes(duration,pred ),color='green')+
  ggtitle('Score by Game Duration')+
  xlab('Time (s)')+
  ylab('Score')+
  mytheme+
  themeBars
cor(as.numeric(more_games_2$duration),more_games_2$score)

summary(mod)
```

```{r}
full_table%>%
  ggplot(aes(x1,y1))+
  geom_bin_2d()+ 
  scale_fill_distiller(palette = "RdPu")+
  theme_void()+
  mytheme+
  ggtitle('Heatmap touch screen')
```
The heat map presented above helps us to understand what parts of the screen 
take more attention. In the zones with more attention the cards  get opened
faster consequently fewer touches.

The interesting fact is the similarity with  [f-pattern of pattern reading on the web](https://www.nngroup.com/articles/f-shaped-pattern-reading-web-content/)
and confirming the pattern on mobiles. 
 
 ![Heatmap Pattern of Reading on the Web.](f-pattern.png)


```{r}
first_emoji<-user_summarise%>%
  group_by(firstEmoji)%>%
  summarise(count= n())%>%
  ggplot(aes(x = reorder(firstEmoji,-count),y=count))+
    geom_bar(stat="identity", mapping=aes( fill=count))+
    scale_fill_distiller(palette = "RdPu" )+
    mytheme+
    themeBars+
    ggtitle('First open emoji')+  
    xlab('emoji')+
    theme(legend.position = "none")

last_emoji<-user_summarise%>%
  group_by(lastEmoji)%>%
  summarise(count= n())%>%
  ggplot(aes(x = reorder(lastEmoji,-count),y=count))+
    geom_bar(stat="identity", mapping=aes(fill=count))+
    scale_fill_distiller(palette = "RdPu" )+
    mytheme+
    themeBars+
    ggtitle('Last open emoji')+ 
    xlab('emoji')+
    theme(legend.position = "none")


plot_grid(first_emoji,last_emoji,nrow=1, ncol=2) + 
  theme(plot.background = element_rect(fill="#0c1329", color = NA))
```




```{r}
emo1_emo2<-full_table%>%select(emoji1,emoji2)

matriz_emojis<-xtabs( ~ emoji1+emoji2, data=emo1_emo2)

matriz_emojis<-matriz_emojis+t(matriz_emojis) # taking advantage of  the symmetry  we can add  the transposed to count (1,2) (2,1) as one

comp<-matriz_emojis
diag(comp)<-0

diag(matriz_emojis)<-0
matriz_emojis[upper.tri(matriz_emojis)] <- 0
most_common_pairs<-as.data.frame(matriz_emojis)%>%filter(Freq!=0)%>% group_by(emoji1)%>%mutate(max=max(Freq))%>%filter(Freq==max)
most_common_pairs%>%
  graph_from_data_frame()%>%
  ggraph(layout = 'sugiyama') +
  geom_edge_link(aes(colour = Freq)) +
  geom_node_point(color = "pink", size = 2) +
  geom_node_text(aes(label = name),colour='white',size=6 ,repel = TRUE) +
  scale_edge_color_distiller(palette = 'Set1')+
  mytheme+theme(
    axis.text.y=element_blank(),
    axis.text.x=element_blank(),
    axis.title = element_blank())+
  ggtitle('Frequency most common wrong pairs')

```